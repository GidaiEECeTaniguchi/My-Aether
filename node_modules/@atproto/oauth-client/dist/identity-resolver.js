"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createIdentityResolver = createIdentityResolver;
const did_resolver_1 = require("@atproto-labs/did-resolver");
const handle_resolver_1 = require("@atproto-labs/handle-resolver");
const identity_resolver_1 = require("@atproto-labs/identity-resolver");
function createIdentityResolver(options) {
    const { identityResolver } = options;
    if (identityResolver != null)
        return identityResolver;
    const didResolver = createDidResolver(options);
    const handleResolver = createHandleResolver(options);
    return new identity_resolver_1.AtprotoIdentityResolver(didResolver, handleResolver);
}
function createDidResolver(options) {
    const { didResolver, didCache } = options;
    if (didResolver instanceof did_resolver_1.DidResolverCached && !didCache) {
        return didResolver;
    }
    return new did_resolver_1.DidResolverCached(didResolver ?? new did_resolver_1.DidResolverCommon(options), didCache);
}
function createHandleResolver(options) {
    const { handleResolver, handleCache } = options;
    if (handleResolver == null) {
        // Because the handle resolution mechanism requires either a DNS based
        // handle resolver or an XRPC based handle resolver, we require the
        // handleResolver option to be provided.
        throw new TypeError('handleResolver is required');
    }
    if (handleResolver instanceof handle_resolver_1.CachedHandleResolver && !handleCache) {
        return handleResolver;
    }
    return new handle_resolver_1.CachedHandleResolver(typeof handleResolver === 'string' || handleResolver instanceof URL
        ? new handle_resolver_1.XrpcHandleResolver(handleResolver, options)
        : handleResolver, handleCache);
}
//# sourceMappingURL=identity-resolver.js.map